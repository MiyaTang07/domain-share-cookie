#!/usr/bin/env node
/**
 * domain set -hå¯å±•ç¤ºhelp info
 * domain set è¯¥commandLineä¸ºäº¤äº’é—®è¯¢å¼ä¿¡æ¯æ”¶é›†
 * äº¦å¯é€šè¿‡ [domain set -f xxx] [domain set -t xxx]æ”¶é›†ä¿¡æ¯
*/
const { Command } = require('commander')
const chalk = require('chalk')
const path = require('path')
const fs = require('fs')


const program = new Command()
const F_SETTED_INFO = 'Domain which offer cookie has been setted upğŸŒ'
const T_SETTED_INFO = 'Domain which consume cookie has been setted upğŸŒ'
const DOMAIN_REG_ERROR = 'ğŸŒ²Domian url is not properly formattedğŸŒ²'
const URL_REG = /^(?=^.{3,255}$)(http(s)?:\/\/)?(www\.)?[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(\.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+(:\d+)*(\/\w+\.\w+)*$/

/**commander optionxiao å°å†™çš„é—®é¢˜*/
program
   .usage('[options]')
   .option('-F, --From <string>', 'add domain url which offer cookie')
   .option('-T, --To <string>', 'add domain url which consume cookie')

program.parse()

/**
 * check domain.json file exist or else create empty {} into it
*/
function domainFileCheck(fileName) {
    if(!fs.existsSync(fileName)) {
       return fs.writeFileSync(fileName, JSON.stringify({}), "utf-8", err => {
           if(err) console.error(err)
           console.log(chalk.red('Something wrong with writeFileSync'))
           process.exit(1)
       })
    } else {
        return fs.readFileSync(fileName, 'utf-8')
    }
}
/**
 * check if from-domain and to-domain is the same domain 
*/
function checkDomainConflict(info_p, info_n) {
   const _info = Object.assign(info_p, info_n)
   const { from, to } = _info
   if(from === to) {
       console.log(`${chalk.red('ğŸŒ²You cannot set two same origin domain urlğŸŒ²')}`)
       process.exit(1)
   }
}


/**
 * write new domain info into domain.json file
*/
function domainInfoWriteSync(options = {from: '', to: ''}) {
    
    let domainInfo = domainFileCheck(path.resolve(process.cwd(), 'domain.json'))
    domainInfo = domainInfo ? JSON.parse(domainInfo) : {}

    const _opts = {...options}

    const additionalInfo = {}
    for(const key in _opts) {
        const val = _opts[key]
        if(val){
            if (!URL_REG.test(val)) {
                console.log(`${chalk.red(DOMAIN_REG_ERROR)}`)
                process.exit(1)
            }
            additionalInfo[key] = val
        } 
    }

    checkDomainConflict(domainInfo, additionalInfo)
    
    Object.assign(domainInfo, additionalInfo)
   
    fs.writeFileSync(path.resolve(process.cwd(), 'domain.json'), JSON.stringify(domainInfo))
    if (_opts.from) {
        console.log(`${chalk.green(F_SETTED_INFO)}`)
    }
    if (_opts.to) {
        console.log(`${chalk.green(T_SETTED_INFO)}`)
    }
    
    process.exit(1)
}

// ----------å‘½ä»¤å¼æ”¶é›†æ–¹å¼start----------
const options = program.opts()
const { From: from, To: to } = options
if (from || to) {
   domainInfoWriteSync({ from, to })
}
// ----------å‘½ä»¤å¼æ”¶é›†æ–¹å¼end----------

// ----------é—®è¯¢å¼æ”¶é›†æ–¹å¼start----------
const inquirer = require('inquirer')
const questions = [
    {
       name: "from",
       type: "input",
       message: "è¯·è¾“å…¥åˆ†äº«cookieçš„åŸŸåurl",
       validate(val) {
           if(!URL_REG.test(val)) {
               return chalk.red(DOMAIN_REG_ERROR)
           }
           return true
       }
    },
    {
        name: "to",
        type: "input",
        message: "è¯·è¾“å…¥æ¶ˆè´¹cookieçš„åŸŸåurl",
        validate(val) {
            if(!URL_REG.test(val)) {
                return chalk.red(DOMAIN_REG_ERROR)
            }
            return true
        }
    }
]

inquirer.prompt(questions).then(output => {
    let { from, to } = output
    from = from.trim()
    to = to.trim()
    domainInfoWriteSync({ from, to })
})

// ----------é—®è¯¢å¼æ”¶é›†æ–¹å¼end----------